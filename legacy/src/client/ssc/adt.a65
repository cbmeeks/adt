        .include "merlin.inc"
.export main

;--------------------------------
; APPLE DISK TRANSFER 1.23
; BY PAUL GUERTIN
; PG@SFF.NET (ALL IN LOWER CASE)
; OCTOBER 13TH, 1994 -- 1999
; DISTRIBUTE FREELY
;--------------------------------
        .LIST   ON

; THIS PROGRAM TRANSFERS A 16-SECTOR DISK
; TO A 140K MS-DOS FILE AND BACK. THE FILE
; FORMAT IS COMPATIBLE WITH RANDY SPURLOCK'S
; APL2EM EMULATOR.
; SSC OR COMPATIBLE HARDWARE IS REQUIRED.
; IIGS REQUIRES SSC OR COMPATIBLE CARD.

; VERSION HISTORY:

; VERSION 1.23 November 2005
; Knut Roll-Lund and Ed Eastman
; - Added 115200b rate for SSC card
; - Added additional baud rates to
;   Windows and DOS verisons
; - added buffering to DIR handling
;   so it works on higher baudrates

; VERSION 1.22 CHANGES "ABOUT" MSG

; VERSION 1.21 FILLS UNREADABLE SECTORS WITH ZEROS

; VERSION 1.20
; - HAS A CONFIGURATION MENU
; - HAS A DIRECTORY FUNCTION
; - ABORTS INSTANTLY IF USER PUSHES ESCAPE
; - FIXES THE "256 RETRIES" BUG
; - HAS MORE EFFICIENT CRC ROUTINES

; VERSION 1.11 SETS IOBVOL TO 0 BEFORE CALLING RWTS

; VERSION 1.10 ADDS THESE ENHANCEMENTS:
; - DIFFERENTIAL RLE COMPRESSION TO SPEED UP TRANSFER
; - 16-BIT CRC ERROR DETECTION
; - AUTOMATIC RE-READS OF BAD SECTORS

; VERSION 1.01 CORRECTS THE FOLLOWING BUGS:
; - INITIALIZATION ROUTINE CRASHED WITH SOME CARDS
; - FULL 8.3 MS-DOS FILENAMES NOW ACCEPTED

; VERSION 1.00 - FIRST PUBLIC RELEASE


; CONSTANTS

esc     = $9b                   ;ESCAPE KEY
ack     = $06                   ;ACKNOWLEDGE
nak     = $15                   ;NEGATIVE ACKNOWLEDGE
parmnum = 8                     ;NUMBER OF CONFIGURABLE PARMS

; ZERO PAGE LOCATIONS (ALL UNUSED BY DOS, BASIC & MONITOR)

msgptr  = $6                    ;POINTER TO MESSAGE TEXT (2B)
secptr  = $8                    ;POINTER TO SECTOR DATA  (2B)
trkcnt  = $1e                   ;COUNTS SEVEN TRACKS     (1B)
crc     = $eb                   ;TRACK CRC-16            (2B)
prev    = $ed                   ;PREVIOUS BYTE FOR RLE   (1B)
ysave   = $ee                   ;TEMP STORAGE            (1B)

; BIG FILES

tracks  = $2000                 ;7 TRACKS AT 2000-8FFF (28KB)
crctbll = $9000                 ;CRC LOW TABLE         (256B)
crctblh = $9100                 ;CRC HIGH TABLE        (256B)

; MONITOR STUFF

ch      = $24                   ;CURSOR HORIZONTAL POSITION
cv      = $25                   ;CURSOR VERTICAL POSITION
basl    = $28                   ;BASE LINE ADDRESS
invflg  = $32                   ;INVERSE FLAG
clreol  = $fc9c                 ;CLEAR TO END OF LINE
clreop  = $fc42                 ;CLEAR TO END OF SCREEN
home    = $fc58                 ;CLEAR WHOLE SCREEN
tabv    = $fb5b                 ;SET BASL FROM A
vtab    = $fc22                 ;SET BASL FROM CV
rdkey   = $fd0c                 ;CHARACTER INPUT
nxtchar = $fd75                 ;LINE INPUT
cout1   = $fdf0                 ;CHARACTER OUTPUT
crout   = $fd8e                 ;OUTPUT RETURN

; MESSAGES

mtitle  = 0                     ;TITLE SCREEN
mconfig = 2                     ;CONFIGURATION TOP OF SCREEN
mconfg2 = 4                     ;CONFIGURATION BOTTOM OF SCREEN
mprompt = 6                     ;MAIN PROMPT
mdircon = 8                     ;CONTINUED DIRECTORY PROMPT
mdirend = 10                    ;END OF DIRECTORY PROMPT
mfrecv  = 12                    ;FILE TO RECEIVE:_
mfsend  = 14                    ;FILE TO SEND:_
mrecv   = 16                    ;RECEIVING FILE_    (_ = SPACE)
msend   = 18                    ;SENDING FILE_
mconfus = 20                    ;NONSENSE FROM PC
mnot16  = 22                    ;NOT A 16 SECTOR DISK
merror  = 24                    ;ERROR: FILE_
mcant   = 26                    ;|CAN'T BE OPENED.     (| = CR)
mexists = 28                    ;|ALREADY EXISTS.
mnot140 = 30                    ;|IS NOT A 140K IMAGE.
mfull   = 32                    ;|DOESN'T FIT ON DISK.
manykey = 34                    ;__ANY KEY:_
mdont   = 36                    ;<- DO NOT CHANGE
mabout  = 38                    ;ABOUT ADT...
mtest   = 40                    ;TESTING DISK FORMAT
mpcans  = 42                    ;AWAITING ANSWER FROM PC

;*********************************************************

        .ORG    $803
main:

        jmp     start           ;SKIP DEFAULT PARAMETERS

default:
        .byte   5,0,1,5,1,0,0,0 ;DEFAULT PARM VALUES

;---------------------------------------------------------
; START - MAIN PROGRAM
;---------------------------------------------------------
start:  cld                     ;BINARY MODE
        jsr     $fe84           ;NORMAL TEXT
        jsr     $fb2f           ;TEXT MODE, FULL WINDOW
        jsr     $fe89           ;INPUT FROM KEYBOARD
        jsr     $fe93           ;OUTPUT TO 40-COL SCREEN

        lda     #0
        sta     secptr          ;SECPTR ALWAYS PAGE-ALIGNED

        sta     stddos          ;ASSUME STANDARD DOS INITIALLY
        lda     $b92e           ;SAVE CONTENTS OF DOS
        sta     dosbyte         ;CHECKSUM BYTES
        cmp     #$13
        beq     dosok1          ;AND DECREMENT STDDOS (MAKING
        dec     stddos          ;IT NONZERO) IF THE CORRECT
dosok1: lda     $b98a           ;BYTES AREN'T THERE
        sta     dosbyte+1
        cmp     #$b7
        beq     dosok2
        dec     stddos

dosok2: jsr     maketbl         ;MAKE CRC-16 TABLES
        jsr     parmdft         ;RESET PARAMETERS TO DEFAULTS
        jsr     parmint         ;INTERPRET PARAMETERS

redraw: jsr     title           ;DRAW TITLE SCREEN

mainlup:
        ldy     #mprompt        ;SHOW MAIN PROMPT
        jsr     showmsg         ;AT BOTTOM OF SCREEN
        jsr     rdkey           ;GET ANSWER
        and     #$df            ;CONVERT TO UPPERCASE
mod0:   bit     $c088           ;CLEAR SSC INPUT REGISTER

        cmp     #_'S'           ;SEND?
        bne     krecv           ;NOPE, TRY RECEIVE
        jsr     send            ;YES, DO SEND ROUTINE
        jmp     mainlup

krecv:  cmp     #_'R'           ;RECEIVE?
        bne     kdir            ;NOPE, TRY DIR
        jsr     receive         ;YES, DO RECEIVE ROUTINE
        jmp     mainlup

kdir:   cmp     #_'D'           ;DIR?
        bne     kconf           ;NOPE, TRY CONFIGURE
        jsr     dir             ;YES, DO DIR ROUTINE
        jmp     redraw

kconf:  cmp     #_'C'           ;CONFIGURE?
        bne     kabout          ;NOPE, TRY ABOUT
        jsr     config          ;YES, DO CONFIGURE ROUTINE
        jsr     parmint         ;AND INTERPRET PARAMETERS
        jmp     redraw

kabout: cmp     #$9f            ;ABOUT MESSAGE? ("?" KEY)
        bne     kquit           ;NOPE, TRY QUIT
        ldy     #mabout         ;YES, SHOW MESSAGE, WAIT
        jsr     showmsg         ;FOR KEY, AND RETURN
        jsr     rdkey
        jmp     mainlup

kquit:  cmp     #_'Q'           ;QUIT?
        bne     mainlup         ;NOPE, WAS A BAD KEY
        lda     dosbyte         ;YES, RESTORE DOS CHECKSUM CODE
        sta     $b92e
        lda     dosbyte+1
        sta     $b98a
        jmp     $3d0            ;AND QUIT TO DOS


;---------------------------------------------------------
; DIR - GET DIRECTORY FROM THE PC AND PRINT IT
; PC SENDS 0,1 AFTER PAGES 1..N-1, 0,0 AFTER LAST PAGE
;---------------------------------------------------------
dir:    jsr     home            ;CLEAR SCREEN
        lda     #_'D'           ;SEND DIR COMMAND TO PC
        jsr     putc

        lda     pspeed
        cmp     #6
        bne     dirloop

        lda     #>tracks        ;GET BUFFER POINTER HIGHBYTE
        sta     secptr+1        ;SET SECTOR BUFFER POINTER
        ldy     #0              ;COUNTER
dirbuff:
        jsr     getc            ;GET SERIAL CHARACTER
        php                     ;SAVE FLAGS
        sta     (secptr),y      ;STORE BYTE
        iny                     ;BUMP
        bne     dirnext         ;SKIP
        inc     secptr+1        ;NEXT 256 BYTES
dirnext:
        plp                     ;RESTORE FLAGS
        bne     dirbuff         ;LOOP UNTIL ZERO

        jsr     getc            ;GET CONTINUATION CHARACTER
        sta     (secptr),y      ;STORE CONTINUATION BYTE TOO

        lda     #>tracks        ;GET BUFFER POINTER HIGHBYTE
        sta     secptr+1        ;SET SECTOR BUFFER POINTER
        ldy     #0              ;COUNTER
dirdisp:
        lda     (secptr),y      ;GET BYTE FROM BUFFER
        php                     ;SAVE FLAGS
        iny                     ;BUMP
        bne     dirmore         ;SKIP
        inc     secptr+1        ;NEXT 256 BYTES
dirmore:
        plp                     ;RESTORE FLAGS
        beq     dirpage         ;PAGE OR DIR END
        ora     #$80
        jsr     cout1           ;DISPLAY
        jmp     dirdisp         ;LOOP

dirpage:
        lda     (secptr),y      ;GET BYTE FROM BUFFER
        bne     dircont

        ldy     #mdirend        ;NO MORE FILES, WAIT FOR KEY
        jsr     showmsg         ;AND RETURN
        jsr     rdkey
        rts

dirloop:
        jsr     getc            ;PRINT PC OUTPUT EXACTLY AS
        beq     dirstop         ;IT ARRIVES (PC IS RESPONSIBLE
        ora     #$80            ;FOR FORMATTING), UNTIL 00
        jsr     cout1           ;RECEIVED
        jmp     dirloop

dirstop:
        jsr     getc            ;GET CONTINUATION CHARACTER
        bne     dircont         ;NOT 00, THERE'S MORE

        ldy     #mdirend        ;NO MORE FILES, WAIT FOR KEY
        jsr     showmsg         ;AND RETURN
        jsr     rdkey
        rts

dircont:
        ldy     #mdircon        ;SPACE TO CONTINUE, ESC TO STOP
        jsr     showmsg
        jsr     rdkey
        eor     #esc            ;NOT ESCAPE, CONTINUE NORMALLY
        bne     dir             ;BY SENDING A "D" TO PC
        jmp     putc            ;ESCAPE, SEND 00 AND RETURN

;---------------------------------------------------------
; CONFIG - ADT CONFIGURATION
;---------------------------------------------------------
config: jsr     home            ;CLEAR SCREEN
        ldy     #mconfig        ;SHOW CONFIGURATION SCREEN
        jsr     showm1
        ldy     #mconfg2
        jsr     showmsg         ;IN 2 PARTS BECAUSE >256 CHARS

        ldy     #parmnum-1      ;SAVE PREVIOUS PARAMETERS
savparm:
        lda     parms,y         ;IN CASE OF ESCAPE
        sta     oldparm,y
        dey
        bpl     savparm

;--------------- FIRST PART: DISPLAY SCREEN --------------

refresh:
        lda     #3              ;FIRST PARAMETER IS ON LINE 3
        jsr     tabv
        ldx     #0              ;PARAMETER NUMBER
        ldy     #$ff            ;OFFSET INTO PARAMETER TEXT

nxtline:
        stx     linecnt         ;SAVE CURRENT LINE
        lda     #15
        sta     ch
        clc
        lda     parmsiz,x       ;GET CURRENT VALUE (NEGATIVE:
        sbc     parms,x         ;LAST VALUE HAS CURVAL=0)
        sta     curval
        lda     parmsiz,x       ;X WILL BE EACH POSSIBLE VALUE
        tax                     ;STARTING WITH THE LAST ONE
        dex

valloop:
        cpx     curval          ;X EQUAL TO CURRENT VALUE?
        beq     printit         ;YES, PRINT IT
skipchr:
        iny                     ;NO, SKIP IT
        lda     parmtxt,y
        bne     skipchr
        beq     endval

printit:
        lda     linecnt         ;IF WE'RE ON THE ACTIVE LINE,
        cmp     curparm         ;THEN PRINT VALUE IN INVERSE
        bne     prtval          ;ELSE PRINT IT NORMALLY
        lda     #$3f
        sta     invflg

prtval: lda     #$a0            ;SPACE BEFORE & AFTER VALUE
        jsr     cout1
prtloop:
        iny                     ;PRINT VALUE
        lda     parmtxt,y
        beq     endprt
        jsr     cout1
        jmp     prtloop
endprt: lda     #$a0
        jsr     cout1
        lda     #$ff            ;BACK TO NORMAL
        sta     invflg
endval: dex
        bpl     valloop         ;PRINT REMAINING VALUES

        sty     ysave           ;CLREOL USES Y
        jsr     clreol          ;REMOVE GARBAGE AT EOL
        jsr     crout
        ldy     ysave
        ldx     linecnt         ;INCREMENT CURRENT LINE
        inx
        cpx     #parmnum
        bcc     nxtline         ;LOOP 8 TIMES

        lda     stddos          ;IF NON-STANDARD DOS, WRITE
        beq     getcmd          ;"DO NOT CHANGE" ON SCREEN
        lda     #9              ;NEXT TO THE CHECKSUMS OPTION
        jsr     tabv
        ldy     #23
        sty     ch
        ldy     #mdont
        jsr     showm1

;--------------- SECOND PART: CHANGE VALUES --------------

getcmd: lda     $c000           ;WAIT FOR NEXT COMMAND
        bpl     getcmd
        bit     $c010
        ldx     curparm         ;CURRENT PARAMETER IN X

        cmp     #$88
        bne     notleft
        dec     parms,x         ;LEFT ARROW PUSHED
        bpl     leftok          ;DECREMENT CURRENT VALUE
        lda     parmsiz,x
        sbc     #1
        sta     parms,x
leftok: jmp     refresh

notleft:
        cmp     #$95
        bne     notrgt
        lda     parms,x         ;RIGHT ARROW PUSHED
        adc     #0              ;INCREMENT CURRENT VALUE
        cmp     parmsiz,x
        bcc     rightok
        lda     #0
rightok:
        sta     parms,x
        jmp     refresh

notrgt: cmp     #$8b
        bne     notup
        dex                     ;UP ARROW PUSHED
        bpl     upok            ;DECREMENT PARAMETER
        ldx     #parmnum-1
upok:   stx     curparm
        jmp     refresh

notup:  cmp     #$8a
        beq     isdown
        cmp     #$a0
        bne     notdown
isdown: inx                     ;DOWN ARROW OR SPACE PUSHED
        cpx     #parmnum        ;INCREMENT PARAMETER
        bcc     downok
        ldx     #0
downok: stx     curparm
        jmp     refresh

notdown:
        cmp     #$84
        bne     notctld
        jsr     parmdft         ;CTRL-D PUSHED, RESTORE DEFAULT
notesc: jmp     refresh         ;PARAMETERS

notctld:
        cmp     #$8d
        beq     endcfg          ;RETURN PUSHED, STOP CONFIGURE

        cmp     #esc
        bne     notesc
        ldy     #parmnum-1      ;ESCAPE PUSHED, RESTORE OLD
parmrst:
        lda     oldparm,y       ;PARAMETERS AND STOP CONFIGURE
        sta     parms,y
        dey
        bpl     parmrst
endcfg: rts

linecnt:
        .byte   $00             ;CURRENT LINE NUMBER
curparm:
        .byte   $00             ;ACTIVE PARAMETER
curval: .byte   $00             ;VALUE OF ACTIVE PARAMETER
oldparm:
        .res    parmnum         ;OLD PARAMETERS SAVED HERE


;---------------------------------------------------------
; PARMINT - INTERPRET PARAMETERS
;---------------------------------------------------------
parmint:
        ldy     pdslot          ;GET SLOT# (0..6)
        iny                     ;NOW 1..7
        tya
        ora     #_'0'           ;CONVERT TO ASCII AND PUT
        sta     mtslt           ;INTO TITLE SCREEN
        tya
        asl
        asl
        asl
        asl                     ;NOW $S0
        sta     iobslt          ;STORE IN IOB
        adc     #$89            ;NOW $89+S0
        sta     mod5+1          ;SELF-MOD FOR "DRIVES ON"

        ldy     pdrive          ;GET DRIVE# (0..1)
        iny                     ;NOW 1..2
        sty     iobdrv          ;STORE IN IOB
        tya
        ora     #_'0'           ;CONVERT TO ASCII AND PUT
        sta     mtdrv           ;INTO TITLE SCREEN

        ldy     pssc            ;GET SSC SLOT# (0..6)
        iny                     ;NOW 1..7
        tya
        ora     #_'0'           ;CONVERT TO ASCII AND PUT
        sta     mtssc           ;INTO TITLE SCREEN
        tya
        asl
        asl
        asl
        asl                     ;NOW $S0
        adc     #$88
        tax
        lda     #$0b            ;COMMAND: NO PARITY, RTS ON,
        sta     $c002,x         ;DTR ON, NO INTERRUPTS
        ldy     pspeed          ;CONTROL: 8 DATA BITS, 1 STOP
        lda     bpsctrl,y       ;BIT, BAUD RATE DEPENDS ON
        sta     $c003,x         ;PSPEED
        stx     mod0+1          ;SELF-MODS FOR $C088+S0
        stx     mod2+1          ;IN MAIN LOOP
        stx     mod4+1          ;AND IN GETC AND PUTC
        inx
        stx     mod1+1          ;SELF-MODS FOR $C089+S0
        stx     mod3+1          ;IN GETC AND PUTC

        tya                     ;GET SPEED (0..6)
        asl
        asl
        adc     pspeed          ;6*SPEED IN Y, NOW COPY
        tay                     ;FIVE CHARACTERS INTO
        ldx     #4              ;TITLE SCREEN
putspd: lda     spdtxt,y
        sta     mtspd,x
        iny
        dex
        bpl     putspd

        ldy     #1              ;CONVERT RETRIES FROM 0..7
trylup: ldx     pretry,y        ;TO 0..5,10,128
        lda     trytbl,x
        sta     realtry,y
        dey
        bpl     trylup

        ldx     #0              ;IF PCKSUM IS 'NO', WE PATCH
        ldy     #0              ;DOS TO IGNORE ADDRESS AND
        lda     pcksum          ;DATA CHECKSUM ERRORS
        bne     rwtsmod
        ldx     dosbyte+1
        ldy     dosbyte
rwtsmod:
        stx     $b98a           ;IS THERE AN APPLE II TODAY
        sty     $b92e           ;THAT DOESN'T HAVE >=48K RAM?
        rts                     ;(YES)

spdtxt: asc     "  003 0021 0042 0084 006900291 K511"
bpsctrl:
        .byte   $16,$18,$1a,$1c,$1e,$1f,$10
trytbl: .byte   0,1,2,3,4,5,10,99


;---------------------------------------------------------
; GETNAME - GET FILENAME AND SEND TO PC
;---------------------------------------------------------
getname:
        stx     directn         ;TFR DIRECTION (0=RECV, 1=SEND)
        ldy     prmptbl,x
        jsr     showmsg         ;ASK FILENAME
        ldx     #0              ;GET ANSWER AT $200
        jsr     nxtchar
        lda     #0              ;NULL-TERMINATE IT
        sta     $200,x
        txa
        bne     fnameok
        jmp     abort           ;ABORT IF NO FILENAME

fnameok:
        ldy     #mtest          ;"TESTING THE DISK"
        jsr     showmsg
        lda     #>tracks        ;READ TRACK 1 SECTOR 1
        sta     iobbuf+1        ;TO SEE IF THERE'S A 16-SECTOR
        lda     #1              ;DISK IN THE DRIVE
        sta     iobcmd
        sta     iobtrk
        sta     iobsec
        lda     #>iob
        ldy     #<iob
        jsr     $3d9
        bcc     diskok          ;READ SUCCESSFUL

        ldy     #mnot16         ;NOT 16-SECTOR DISK
        jsr     showmsg
        ldy     #manykey        ;APPEND PROMPT
        jsr     showm1
        jsr     awbeep
        jsr     rdkey           ;WAIT FOR KEY
        jmp     abort           ;AND ABORT

diskok: ldy     #mpcans         ;"AWAITING ANSWER FROM PC"
        jsr     showmsg
        lda     #_'R'           ;LOAD ACC WITH "R" OR "S"
        adc     directn
        jsr     putc            ;AND SEND TO PC
        ldx     #0
fnloop: lda     $200,x          ;SEND FILENAME TO PC
        jsr     putc
        beq     getans          ;STOP AT NULL
        inx
        bne     fnloop

getans: jsr     getc            ;ANSWER FROM PC SHOULD BE 0
        bne     pcerror         ;THERE'S A PROBLEM

        jsr     title           ;CLEAR STATUS
        ldx     directn
        ldy     tfrtbl,x
        jsr     showmsg         ;SHOW TRANSFER MESSAGE

showfn: lda     #2              ;AND ADD FILENAME
        sta     msgptr+1
        lda     #0
        sta     msgptr
        tay
        jmp     msgloop         ;AND RETURN THROUGH SHOWMSG

pcerror:
        pha                     ;SAVE ERROR NUMBER
        ldy     #merror         ;SHOW "ERROR: FILE "
        jsr     showmsg         ;SHOW FILENAME
        jsr     showfn
        pla
        tay
        jsr     showm1          ;SHOW ERROR MESSAGE
        ldy     #manykey        ;APPEND PROMPT
        jsr     showm1
        jsr     awbeep
        jsr     rdkey           ;WAIT FOR KEY
        jmp     abort           ;AND RESTART

directn:
        .byte   $00
prmptbl:
        .byte   mfrecv,mfsend
tfrtbl: .byte   mrecv,msend


;---------------------------------------------------------
; RECEIVE - MAIN RECEIVE ROUTINE
;---------------------------------------------------------
receive:
        ldx     #0              ;DIRECTION = PC-->APPLE
        jsr     getname         ;ASK FOR FILENAME & SEND TO PC
        lda     #ack            ;1ST MESSAGE ALWAYS ACK
        sta     message
        lda     #0              ;START ON TRACK 0
        sta     iobtrk
        sta     errors          ;NO DISK ERRORS YET

recvlup:
        sta     savtrk          ;SAVE CURRENT TRACK
        ldx     #1
        jsr     sr7trk          ;RECEIVE 7 TRACKS FROM PC
        ldx     #2
        jsr     rw7trk          ;WRITE 7 TRACKS TO DISK
        lda     iobtrk
        cmp     #$23            ;REPEAT UNTIL TRACK $23
        bcc     recvlup
        lda     message         ;SEND LAST ACK
        jsr     putc
        lda     errors
        jsr     putc            ;SEND ERROR FLAG TO PC
        jmp     awbeep          ;BEEP AND END


;---------------------------------------------------------
; SEND - MAIN SEND ROUTINE
;---------------------------------------------------------
send:   ldx     #1              ;DIRECTION = APPLE-->PC
        jsr     getname         ;ASK FOR FILENAME & SEND TO PC
        lda     #ack            ;SEND INITIAL ACK
        jsr     putc
        lda     #0              ;START ON TRACK 0
        sta     iobtrk
        sta     errors          ;NO DISK ERRORS YET

sendlup:
        sta     savtrk          ;SAVE CURRENT TRACK
        ldx     #1
        jsr     rw7trk          ;READ 7 TRACKS FROM DISK
        ldx     #0
        jsr     sr7trk          ;SEND 7 TRACKS TO PC
        lda     iobtrk
        cmp     #$23            ;REPEAT UNTIL TRACK $23
        bcc     sendlup
        lda     errors
        jsr     putc            ;SEND ERROR FLAG TO PC
        jmp     awbeep          ;BEEP AND END


;---------------------------------------------------------
; SR7TRK - SEND (X=0) OR RECEIVE (X=1) 7 TRACKS
;---------------------------------------------------------
sr7trk: stx     what2do         ;X=0 FOR SEND, X=1 FOR RECEIVE
        lda     #7              ;DO 7 TRACKS
        sta     trkcnt
        lda     #>tracks        ;STARTING HERE
        sta     secptr+1
        jsr     homecur         ;RESET CURSOR POSITION

s7trk:  lda     #$f             ;COUNT SECTORS FROM F TO 0
        sta     iobsec
s7sec:  ldx     what2do         ;PRINT STATUS CHARACTER
        lda     srchar,x
        jsr     chrover

        lda     what2do         ;EXECUTE SEND OR RECEIVE
        bne     dorecv          ;ROUTINE

;------------------------ SENDING ------------------------

        jsr     sendsec         ;SEND CURRENT SECTOR
        lda     crc             ;FOLLOWED BY CRC
        jsr     putc
        lda     crc+1
        jsr     putc
        jsr     getc            ;GET RESPONSE FROM PC
        cmp     #ack            ;IS IT ACK?
        beq     srokay          ;YES, ALL RIGHT
        cmp     #nak            ;IS IT NAK?
        beq     s7sec           ;YES, SEND AGAIN

        ldy     #mconfus        ;SOMETHING IS WRONG
        jsr     showmsg         ;TELL BAD NEWS
        ldy     #manykey        ;APPEND PROMPT
        jsr     showm1
        jsr     awbeep
        jsr     rdkey           ;WAIT FOR KEY
        jmp     abort           ;AND ABORT

;----------------------- RECEIVING -----------------------

dorecv: ldy     #0              ;CLEAR NEW SECTOR
        tya
clrloop:
        sta     (secptr),y
        iny
        bne     clrloop

        lda     message         ;SEND RESULT OF PREV SECTOR
        jsr     putc
        jsr     recvsec         ;RECEIVE SECTOR
        jsr     getc
        sta     pccrc           ;AND CRC
        jsr     getc
        sta     pccrc+1
        jsr     undiff          ;UNCOMPRESS SECTOR

        lda     crc             ;CHECK RECEIVED CRC VS
        cmp     pccrc           ;CALCULATED CRC
        bne     recverr
        lda     crc+1
        cmp     pccrc+1
        beq     srokay

recverr:
        lda     #nak            ;CRC ERROR, ASK FOR RESEND
        sta     message
        bne     s7sec

;------------------ BACK TO COMMON LOOP ------------------

srokay: jsr     chrrest         ;RESTORE PREVIOUS STATUS CHAR
        inc     secptr+1        ;NEXT SECTOR
        dec     iobsec
        bpl     s7sec           ;TRACK NOT FINISHED
        lda     trkcnt
        cmp     #2              ;STARTING LAST TRACK, TURN
        bne     notone          ;DRIVE ON, EXCEPT IN THE LAST
        lda     savtrk          ;BLOCK
        cmp     #$1c
        beq     notone
mod5:   bit     $c089

notone: dec     trkcnt
        beq     srend
        jmp     s7trk           ;LOOP UNTIL 7 TRACKS DONE
srend:  rts

srchar: asc     "OI"            ;STATUS CHARACTERS: OUT/IN
what2do:
        .byte   $00


;---------------------------------------------------------
; SENDSEC - SEND CURRENT SECTOR WITH RLE
; CRC IS COMPUTED BUT NOT SENT
;---------------------------------------------------------
sendsec:
        ldy     #0              ;START AT FIRST BYTE
        sty     crc             ;ZERO CRC
        sty     crc+1
        sty     prev            ;NO PREVIOUS CHARACTER
ss1:    lda     (secptr),y      ;GET BYTE TO SEND
        jsr     updcrc          ;UPDATE CRC
        tax                     ;KEEP A COPY IN X
        sec                     ;SUBTRACT FROM PREVIOUS
        sbc     prev
        stx     prev            ;SAVE PREVIOUS BYTE
        jsr     putc            ;SEND DIFFERENCE
        beq     ss3             ;WAS IT A ZERO?
        iny                     ;NO, DO NEXT BYTE
        bne     ss1             ;LOOP IF MORE TO DO
        rts                     ;ELSE RETURN

ss2:    jsr     updcrc
ss3:    iny                     ;ANY MORE BYTES?
        beq     ss4             ;NO, IT WAS 00 UP TO END
        lda     (secptr),y      ;LOOK AT NEXT BYTE
        cmp     prev
        beq     ss2             ;SAME AS BEFORE, CONTINUE
ss4:    tya                     ;DIFFERENCE NOT A ZERO
        jsr     putc            ;SEND NEW ADDRESS
        bne     ss1             ;AND GO BACK TO MAIN LOOP
        rts                     ;OR RETURN IF NO MORE BYTES


;---------------------------------------------------------
; RECVSEC - RECEIVE SECTOR WITH RLE (NO TIME TO UNDIFF)
;---------------------------------------------------------
recvsec:
        ldy     #0              ;START AT BEGINNING OF BUFFER
rc1:    jsr     getc            ;GET DIFFERENCE
        beq     rc2             ;IF ZERO, GET NEW INDEX
        sta     (secptr),y      ;ELSE PUT CHAR IN BUFFER
        iny                     ;AND INCREMENT INDEX
        bne     rc1             ;LOOP IF NOT AT BUFFER END
        rts                     ;ELSE RETURN
rc2:    jsr     getc            ;GET NEW INDEX
        tay                     ;IN Y REGISTER
        bne     rc1             ;LOOP IF INDEX <> 0
        rts                     ;ELSE RETURN


;---------------------------------------------------------
; UNDIFF -  FINISH RLE DECOMPRESSION AND UPDATE CRC
;---------------------------------------------------------
undiff: ldy     #0
        sty     crc             ;CLEAR CRC
        sty     crc+1
        sty     prev            ;INITIAL BASE IS ZERO
udloop: lda     (secptr),y      ;GET NEW DIFFERENCE
        clc
        adc     prev            ;ADD TO BASE
        jsr     updcrc          ;UPDATE CRC
        sta     prev            ;THIS IS THE NEW BASE
        sta     (secptr),y      ;STORE REAL BYTE
        iny
        bne     udloop          ;REPEAT 256 TIMES
        rts


;---------------------------------------------------------
; RW7TRK - READ (X=1) OR WRITE (X=2) 7 TRACKS
; USES A,X,Y. IF ESCAPE, CALLS ABORT
;---------------------------------------------------------
rw7trk: stx     iobcmd          ;X=1 FOR READ, X=2 FOR WRITE
        lda     #7              ;COUNT 7 TRACKS
        sta     trkcnt
        lda     #>tracks        ;START AT BEGINNING OF BUFFER
        sta     iobbuf+1
        jsr     homecur         ;RESET CURSOR POSITION

nexttrk:
        lda     #$f             ;START AT SECTOR F (READ IS
        sta     iobsec          ;FASTER THIS WAY)
nextsec:
        ldx     iobcmd          ;GET MAX RETRIES FROM
        lda     realtry-1,x     ;PARAMETER DATA
        sta     retries
        lda     rwchar-1,x      ;PRINT STATUS CHARACTER
        jsr     chrover

rwagain:
        lda     $c000           ;CHECK KEYBOARD
        cmp     #esc            ;ESCAPE PUSHED?
        bne     rwcont          ;NO, CONTINUE
        jmp     sabort          ;YES, ABORT

rwcont: lda     #>iob           ;GET IOB ADDRESS IN REGISTERS
        ldy     #<iob
        jsr     $3d9            ;CALL RWTS THROUGH VECTOR
        lda     #_'.'           ;CARRY CLEAR MEANS NO ERROR
        bcc     sectok          ;NO ERROR: PUT . IN STATUS
        dec     retries         ;ERROR: SOME PATIENCE LEFT?
        bpl     rwagain         ;YES, TRY AGAIN
        rol     errors          ;NO, SET ERRORS TO NONZERO
        jsr     clrsect         ;FILL SECTOR WITH ZEROS
        lda     #_I'*'          ;AND PUT INVERSE * IN STATUS

sectok: jsr     chradv          ;PRINT SECTOR STATUS & ADVANCE
        inc     iobbuf+1        ;NEXT PAGE IN BUFFER
        dec     iobsec          ;NEXT SECTOR
        bpl     nextsec         ;LOOP UNTIL END OF TRACK
        inc     iobtrk          ;NEXT TRACK
        dec     trkcnt          ;LOOP UNTIL 7 TRACKS DONE
        bne     nexttrk
        rts

rwchar: asc     "RW"            ;STATUS CHARACTERS: READ/WRITE
retries:
        .byte   $00
realtry:
        .byte   $00,$00         ;REAL NUMBER OF RETRIES


;---------------------------------------------------------
; CLRSECT - CLEAR CURRENT SECTOR
;---------------------------------------------------------
clrsect:
        lda     iobbuf+1        ;POINT TO CORRECT SECTOR
        sta     csloop+2
        ldy     #0              ;AND FILL 256 ZEROS
        tya
csloop: sta     $ff00,y
        iny
        bne     csloop
        rts


;---------------------------------------------------------
; HOMECUR - RESET CURSOR POSITION TO 1ST SECTOR
; CHRREST - RESTORE PREVIOUS CONTENTS & ADVANCE CURSOR
; CHRADV  - WRITE NEW CONTENTS & ADVANCE CURSOR
; ADVANCE - JUST ADVANCE CURSOR
; CHROVER - JUST WRITE NEW CONTENTS
;---------------------------------------------------------
homecur:
        ldy     savtrk
        iny                     ;CURSOR ON 0TH COLUMN
        sty     ch
        jsr     topnext         ;TOP OF 1ST COLUMN
        jmp     chrsave         ;SAVE 1ST CHARACTER

chrrest:
        lda     savchr          ;RESTORE OLD CHARACTER
chradv: jsr     chrover         ;OVERWRITE STATUS CHAR
        jsr     advance         ;ADVANCE CURSOR
chrsave:
        ldy     ch
        lda     (basl),y        ;SAVE NEW CHARACTER
        sta     savchr
        rts

advance:
        inc     cv              ;CURSOR DOWN
        lda     cv
        cmp     #21             ;STILL IN DISPLAY?
        bcc     nowrap          ;YES, WE'RE DONE
topnext:
        inc     ch              ;NO, GO TO TOP OF NEXT
        lda     #5              ;COLUMN
nowrap: jmp     tabv            ;VALIDATE BASL,H

chrover:
        ldy     ch
        sta     (basl),y
        rts


;---------------------------------------------------------
; UPDCRC - UPDATE CRC WITH CONTENTS OF ACCUMULATOR
;---------------------------------------------------------
updcrc: pha
        eor     crc+1
        tax
        lda     crc
        eor     crctblh,x
        sta     crc+1
        lda     crctbll,x
        sta     crc
        pla
        rts


;---------------------------------------------------------
; MAKETBL - MAKE CRC-16 TABLES
;---------------------------------------------------------
maketbl:
        ldx     #0
        ldy     #0
crcbyte:
        stx     crc             ;LOW BYTE = 0
        sty     crc+1           ;HIGH BYTE = INDEX

        ldx     #8              ;FOR EACH BIT
crcbit: lda     crc
crcbit1:
        asl                     ;SHIFT CRC LEFT
        rol     crc+1
        bcs     crcflip
        dex                     ;HIGH BIT WAS CLEAR, DO NOTHING
        bne     crcbit1
        beq     crcsave
crcflip:
        eor     #$21            ;HIGH BIT WAS SET, FLIP BITS
        sta     crc             ;0, 5, AND 12
        lda     crc+1
        eor     #$10
        sta     crc+1
        dex
        bne     crcbit

        lda     crc             ;STORE CRC IN TABLES
crcsave:
        sta     crctbll,y
        lda     crc+1
        sta     crctblh,y
        iny
        bne     crcbyte         ;DO NEXT BYTE
        rts


;---------------------------------------------------------
; PARMDFT - RESET PARAMETERS TO DEFAULT VALUES (USES AX)
;---------------------------------------------------------
parmdft:
        ldx     #parmnum-1
dftloop:
        lda     default,x
        sta     parms,x
        dex
        bpl     dftloop
        rts


;---------------------------------------------------------
; AWBEEP - CUTE TWO-TONE BEEP (USES AXY)
;---------------------------------------------------------
awbeep: lda     psound          ;IF SOUND OFF, RETURN NOW
        bne     nobeep
        lda     #$80            ;STRAIGHT FROM APPLE WRITER ][
        jsr     beep1           ;(CANNIBALISM IS THE SINCEREST
        lda     #$a0            ;FORM OF FLATTERY)
beep1:  ldy     #$80
beep2:  tax
beep3:  dex
        bne     beep3
        bit     $c030           ;WHAP SPEAKER
        dey
        bne     beep2
nobeep: rts


;---------------------------------------------------------
; PUTC - SEND ACC OVER THE SERIAL LINE (AXY UNCHANGED)
;---------------------------------------------------------
putc:   pha
putc1:  lda     $c000
        cmp     #esc            ;ESCAPE = ABORT
        beq     sabort
mod1:   lda     $c089           ;CHECK STATUS BITS
        and     #$70
        cmp     #$10
        bne     putc1           ;OUTPUT REG FULL, LOOP
        pla
mod2:   sta     $c088           ;PUT CHARACTER
        rts


;---------------------------------------------------------
; GETC - GET A CHARACTER FROM SERIAL LINE (XY UNCHANGED)
;---------------------------------------------------------
getc:   lda     $c000
        cmp     #esc            ;ESCAPE = ABORT
        beq     sabort
mod3:   lda     $c089           ;CHECK STATUS BITS
        and     #$68
        cmp     #$8
        bne     getc            ;INPUT REG EMPTY, LOOP
mod4:   lda     $c088           ;GET CHARACTER
        rts


;---------------------------------------------------------
; ABORT - STOP EVERYTHING (CALL SABORT TO BEEP ALSO)
;---------------------------------------------------------
sabort: jsr     awbeep          ;BEEP
abort:  ldx     #$ff            ;POP GOES THE STACKPTR
        txs
        bit     $c010           ;STROBE KEYBOARD
        jmp     redraw          ;AND RESTART


;---------------------------------------------------------
; TITLE - SHOW TITLE SCREEN
;---------------------------------------------------------
title:  jsr     home            ;CLEAR SCREEN
        ldy     #mtitle
        jsr     showm1          ;SHOW TOP PART OF TITLE SCREEN

        ldx     #15             ;SHOW SECTOR NUMBERS
        lda     #5              ;IN DECREASING ORDER
        sta     cv              ;FROM TOP TO BOTTOM
showsec:
        jsr     vtab
        lda     #$20
        ldy     #38
        sta     (basl),y
        ldy     #0
        sta     (basl),y
        lda     hexnum,x
        iny
        sta     (basl),y
        ldy     #37
        sta     (basl),y
        inc     cv
        dex
        bpl     showsec

        lda     #_'_'           ;SHOW LINE OF UNDERLINES
        ldx     #38             ;ABOVE INVERSE TEXT
showund:
        sta     $500,x
        dex
        bpl     showund
        rts


;---------------------------------------------------------
; SHOWMSG - SHOW NULL-TERMINATED MESSAGE #Y AT BOTTOM OF
; SCREEN.  CALL SHOWM1 TO SHOW ANYWHERE WITHOUT ERASING
;---------------------------------------------------------
showmsg:
        sty     ysave           ;CLREOP USES Y
        lda     #0
        sta     ch              ;COLUMN 0
        lda     #22             ;LINE 22
        jsr     tabv
        jsr     clreop          ;CLEAR MESSAGE AREA
        ldy     ysave

showm1: lda     msgtbl,y        ;CALL HERE TO SHOW ANYWHERE
        sta     msgptr
        lda     msgtbl+1,y
        sta     msgptr+1

        ldy     #0
msgloop:
        lda     (msgptr),y
        beq     msgend
        jsr     cout1
        iny
        bne     msgloop
msgend: rts


;------------------------ MESSAGES -----------------------

msgtbl: .addr   msg01,msg02,msg03,msg04,msg05,msg06,msg07
        .addr   msg08,msg09,msg10,msg11,msg12,msg13,msg14
        .addr   msg15,msg16,msg17,msg18,msg19,msg20,msg21
        .addr   msg22

msg01:  asc     "SSC:S"
mtssc:  asc     " ,"
mtspd:  asc     "       "
        inv     "+ ADT 1.23 +"
        asc     "   DISK:S"
mtslt:  asc     " ,D"
mtdrv:  asc     " "
        .byte   $8d,$8d,$8d
        invcr   "  00000000000000001111111111111111222  "
        inv     "  "
hexnum: inv     "0123456789ABCDEF0123456789ABCDEF012  "
        .byte   $8d,$00

msg02:  inv     " ADT CONFIGURATION "
        .byte   $8d,$8d,$8d
        asccr   "DISK SLOT"
        asccr   "DISK DRIVE"
        asccr   "SSC SLOT"
        asccr   "SSC SPEED"
        asccr   "READ RETRIES"
        asccr   "WRITE RETRIES"
        asccr   "USE CHECKSUMS"
        ascz    "ENABLE SOUND"

msg03:  asccr   "USE ARROWS AND SPACE TO CHANGE VALUES,"
        ascz    "RETURN TO ACCEPT, CTRL-D FOR DEFAULTS."

msg04:  ascz    "SEND, RECEIVE, DIR, CONFIGURE, QUIT? "
msg05:  ascz    "SPACE TO CONTINUE, ESC TO STOP: "
msg06:  ascz    "END OF DIRECTORY, TYPE SPACE: "

msg07:  ascz    "FILE TO RECEIVE: "
msg08:  ascz    "FILE TO SEND: "

msg09:  ascz    "RECEIVING FILE "
msg10:  ascz    "SENDING FILE "

msg11:  inv     "ERROR:"
        ascz    " NONSENSE FROM PC."

msg12:  inv     "ERROR:"
        ascz    " NOT A 16-SECTOR DISK."

msg13:  inv     "ERROR:"
        ascz    " FILE "

msg14:  .byte   $8d
        ascz    "CAN'T BE OPENED."

msg15:  .byte   $8d
        ascz    "ALREADY EXISTS."

msg16:  .byte   $8d
        ascz    "IS NOT A 140K IMAGE."

msg17:  .byte   $8d
        ascz    "DOESN'T FIT ON DISK."

msg18:  ascz    "  ANY KEY: "

msg19:  ascz    "<- DO NOT CHANGE"

msg20:  asccr   "APPLE DISK TRANSFER 1.24     1994-10-13"
        ascz    "PAUL GUERTIN (SSC COMPAT HDW REQUIRED.)"

msg21:  ascz    "TESTING DISK FORMAT."

msg22:  ascz    "AWAITING ANSWER FROM PC."


;----------------------- PARAMETERS ----------------------

parmsiz:
        .byte   7,2,7,7,8,8,2,2 ;#OPTIONS OF EACH PARM

parmtxt:
        .byte   _'1',0,_'2',0,_'3',0,_'4',0,_'5',0,_'6',0,_'7',0
        .byte   _'1',0,_'2',0
        .byte   _'1',0,_'2',0,_'3',0,_'4',0,_'5',0,_'6',0,_'7',0
        .byte   _'3',_'0',_'0',0,_'1',_'2',_'0',_'0',0,_'2',_'4',_'0',_'0',0
        .byte   _'4',_'8',_'0',_'0',0,_'9',_'6',_'0',_'0',0,_'1',_'9',_'2',_'0',_'0',0
        .byte   _'1',_'1',_'5',_'K',0
        .byte   _'0',0,_'1',0,_'2',0,_'3',0,_'4',0,_'5',0,_'1',_'0',0,_'9',_'9',0
        .byte   _'0',0,_'1',0,_'2',0,_'3',0,_'4',0,_'5',0,_'1',_'0',0,_'9',_'9',0
        .byte   _'Y',_'E',_'S',0,_'N',_'O',0
        .byte   _'Y',_'E',_'S',0,_'N',_'O',0

parms:
pdslot: .byte   5               ;DISK SLOT (6)
pdrive: .byte   0               ;DISK DRIVE (1)
pssc:   .byte   1               ;SSC SLOT (2)
pspeed: .byte   5               ;SSC SPEED (19200)
pretry: .byte   1,0             ;READ/WRITE MAX RETRIES (1,0)
pcksum: .byte   0               ;USE RWTS CHECKSUMS? (Y)
psound: .byte   0               ;SOUND AT END OF TRANSFER? (Y)

;-------------------------- IOB --------------------------

iob:    .byte   $01             ;IOB TYPE
iobslt: .byte   $60             ;SLOT*$10
iobdrv: .byte   $01             ;DRIVE
        .byte   $00             ;VOLUME
iobtrk: .byte   $00             ;TRACK
iobsec: .byte   $00             ;SECTOR
        .addr   dct             ;DEVICE CHAR TABLE POINTER
iobbuf: .addr   tracks          ;SECTOR BUFFER POINTER
        .byte   $00,$00         ;UNUSED
iobcmd: .byte   $01             ;COMMAND (1=READ, 2=WRITE)
        .byte   $00             ;ERROR CODE
        .byte   $fe             ;ACTUAL VOLUME
        .byte   $60             ;PREVIOUS SLOT
        .byte   $01             ;PREVIOUS DRIVE
dct:    .byte   $00,$01,$ef,$d8 ;DEVICE CHARACTERISTICS TABLE

;-------------------------- MISC -------------------------

dosbyte:
        .byte   $00,$00         ;DOS BYTES CHANGED BY ADT
stddos: .byte   $00             ;ZERO IF "STANDARD" DOS
savtrk: .byte   $00             ;FIRST TRACK OF SEVEN
savchr: .byte   $00             ;CHAR OVERWRITTEN WITH STATUS
message:
        .byte   $00             ;SECTOR STATUS SENT TO PC
pccrc:  .byte   $00,$00         ;CRC RECEIVED FROM PC
errors: .byte   $00             ;NON0 IF AT LEAST 1 DISK ERROR

